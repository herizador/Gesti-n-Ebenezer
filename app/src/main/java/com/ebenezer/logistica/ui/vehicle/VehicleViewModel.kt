package com.ebenezer.logistica.ui.vehicle

import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import androidx.lifecycle.viewmodel.initializer
import androidx.lifecycle.viewmodel.viewModelFactory
import com.ebenezer.logistica.EbenezerApplication
import com.ebenezer.logistica.data.model.Vehicle
import com.ebenezer.logistica.data.model.VehicleState
import com.ebenezer.logistica.data.repository.VehicleRepository
import com.ebenezer.logistica.logic.AlarmScheduler
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch

class VehicleViewModel(
    private val vehicleRepository: VehicleRepository,
    private val alarmScheduler: AlarmScheduler
) : ViewModel() {

    val allVehicles: StateFlow<List<Vehicle>> = vehicleRepository.getAllVehicles()
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = emptyList()
        )

    fun saveVehicle(vehicle: Vehicle) {
        viewModelScope.launch {
            if (vehicle.id == 0) {
              val newId = vehicleRepository.insertVehicle(vehicle)
              // Schedule alarm for the NEW vehicle with the correct ID if needed, 
              // BUT alarmScheduler uses the vehicle object passed. 
              // If we need the ID generated by Room, we should use the one returned.
              val outputVehicle = vehicle.copy(id = newId.toInt())
              alarmScheduler.scheduleVehicleRenewalAlarm(outputVehicle)
            } else {
              vehicleRepository.updateVehicle(vehicle)
              alarmScheduler.scheduleVehicleRenewalAlarm(vehicle) // Update alarm
            }
        }
    }

    fun deleteVehicle(vehicle: Vehicle) {
        viewModelScope.launch {
            alarmScheduler.cancelVehicleAlarm(vehicle)
            vehicleRepository.deleteVehicle(vehicle)
        }
    }
    
    // For specific queries (search/filter), we can expose methods that return Flows or update a StateFlow
    // Simplified for now
    fun getVehicleById(id: Int): StateFlow<Vehicle?> {
        // This is tricky with simple StateFlow/Repository pattern without loading states
        // Ideally we fetch it once or observe it.
        // For simplicity allow fetching in UI via LaunchedEffect calling a suspend function, 
        // or just expose a flow here.
        return kotlinx.coroutines.flow.flow { emit(vehicleRepository.getVehicleById(id)) }
             .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), null)
    }

    companion object {
        val Factory: ViewModelProvider.Factory = viewModelFactory {
            initializer {
                val application = (this[ViewModelProvider.AndroidViewModelFactory.APPLICATION_KEY] as EbenezerApplication)
                val repository = application.container.vehicleRepository
                val alarmScheduler = application.container.alarmScheduler
                VehicleViewModel(repository, alarmScheduler)
            }
        }
    }
}
